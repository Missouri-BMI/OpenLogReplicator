// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: OraProtoBuf.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_OraProtoBuf_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_OraProtoBuf_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3013000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3013000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_OraProtoBuf_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_OraProtoBuf_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[7]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_OraProtoBuf_2eproto;
namespace OpenLogReplicator {
namespace pb {
class Column;
class ColumnDefaultTypeInternal;
extern ColumnDefaultTypeInternal _Column_default_instance_;
class Payload;
class PayloadDefaultTypeInternal;
extern PayloadDefaultTypeInternal _Payload_default_instance_;
class RedoRequest;
class RedoRequestDefaultTypeInternal;
extern RedoRequestDefaultTypeInternal _RedoRequest_default_instance_;
class RedoResponse;
class RedoResponseDefaultTypeInternal;
extern RedoResponseDefaultTypeInternal _RedoResponse_default_instance_;
class Schema;
class SchemaDefaultTypeInternal;
extern SchemaDefaultTypeInternal _Schema_default_instance_;
class SchemaRequest;
class SchemaRequestDefaultTypeInternal;
extern SchemaRequestDefaultTypeInternal _SchemaRequest_default_instance_;
class Value;
class ValueDefaultTypeInternal;
extern ValueDefaultTypeInternal _Value_default_instance_;
}  // namespace pb
}  // namespace OpenLogReplicator
PROTOBUF_NAMESPACE_OPEN
template<> ::OpenLogReplicator::pb::Column* Arena::CreateMaybeMessage<::OpenLogReplicator::pb::Column>(Arena*);
template<> ::OpenLogReplicator::pb::Payload* Arena::CreateMaybeMessage<::OpenLogReplicator::pb::Payload>(Arena*);
template<> ::OpenLogReplicator::pb::RedoRequest* Arena::CreateMaybeMessage<::OpenLogReplicator::pb::RedoRequest>(Arena*);
template<> ::OpenLogReplicator::pb::RedoResponse* Arena::CreateMaybeMessage<::OpenLogReplicator::pb::RedoResponse>(Arena*);
template<> ::OpenLogReplicator::pb::Schema* Arena::CreateMaybeMessage<::OpenLogReplicator::pb::Schema>(Arena*);
template<> ::OpenLogReplicator::pb::SchemaRequest* Arena::CreateMaybeMessage<::OpenLogReplicator::pb::SchemaRequest>(Arena*);
template<> ::OpenLogReplicator::pb::Value* Arena::CreateMaybeMessage<::OpenLogReplicator::pb::Value>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace OpenLogReplicator {
namespace pb {

enum Op : int {
  BEGIN = 0,
  COMMIT = 1,
  INSERT = 2,
  UPDATE = 3,
  DELETE = 4,
  DDL = 5,
  Op_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Op_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Op_IsValid(int value);
constexpr Op Op_MIN = BEGIN;
constexpr Op Op_MAX = DDL;
constexpr int Op_ARRAYSIZE = Op_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Op_descriptor();
template<typename T>
inline const std::string& Op_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Op>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Op_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Op_descriptor(), enum_t_value);
}
inline bool Op_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Op* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Op>(
    Op_descriptor(), name, value);
}
enum ColumnType : int {
  UNKNOWN = 0,
  VARCHAR2 = 1,
  NUMBER = 2,
  LONG = 3,
  DATE = 4,
  RAW = 5,
  LONG_RAW = 6,
  ROWID = 7,
  CHAR = 8,
  BINARY_FLOAT = 9,
  BINARY_DOUBLE = 10,
  CLOB = 11,
  BLOB = 12,
  TIMESTAMP = 13,
  TIMESTAMP_WITH_TZ = 14,
  INTERVAL_YEAR_TO_MONTH = 15,
  INTERVAL_DAY_TO_SECOND = 16,
  UROWID = 17,
  TIMESTAMP_WITH_LOCAL_TZ = 18,
  ColumnType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ColumnType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ColumnType_IsValid(int value);
constexpr ColumnType ColumnType_MIN = UNKNOWN;
constexpr ColumnType ColumnType_MAX = TIMESTAMP_WITH_LOCAL_TZ;
constexpr int ColumnType_ARRAYSIZE = ColumnType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ColumnType_descriptor();
template<typename T>
inline const std::string& ColumnType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ColumnType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ColumnType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ColumnType_descriptor(), enum_t_value);
}
inline bool ColumnType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ColumnType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ColumnType>(
    ColumnType_descriptor(), name, value);
}
enum RequestCode : int {
  INFO = 0,
  START = 1,
  REDO = 2,
  CONFIRM = 3,
  RequestCode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  RequestCode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool RequestCode_IsValid(int value);
constexpr RequestCode RequestCode_MIN = INFO;
constexpr RequestCode RequestCode_MAX = CONFIRM;
constexpr int RequestCode_ARRAYSIZE = RequestCode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RequestCode_descriptor();
template<typename T>
inline const std::string& RequestCode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RequestCode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RequestCode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    RequestCode_descriptor(), enum_t_value);
}
inline bool RequestCode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RequestCode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<RequestCode>(
    RequestCode_descriptor(), name, value);
}
enum ResponseCode : int {
  READY = 0,
  FAILED_START = 1,
  STARTED = 2,
  ALREADY_STARTED = 3,
  STREAMING = 4,
  PAYLOAD = 5,
  INVALID_DATABASE = 6,
  INVALID_COMMAND = 7,
  ResponseCode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ResponseCode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ResponseCode_IsValid(int value);
constexpr ResponseCode ResponseCode_MIN = READY;
constexpr ResponseCode ResponseCode_MAX = INVALID_COMMAND;
constexpr int ResponseCode_ARRAYSIZE = ResponseCode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ResponseCode_descriptor();
template<typename T>
inline const std::string& ResponseCode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ResponseCode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ResponseCode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ResponseCode_descriptor(), enum_t_value);
}
inline bool ResponseCode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ResponseCode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ResponseCode>(
    ResponseCode_descriptor(), name, value);
}
// ===================================================================

class Value PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:OpenLogReplicator.pb.Value) */ {
 public:
  inline Value() : Value(nullptr) {}
  virtual ~Value();

  Value(const Value& from);
  Value(Value&& from) noexcept
    : Value() {
    *this = ::std::move(from);
  }

  inline Value& operator=(const Value& from) {
    CopyFrom(from);
    return *this;
  }
  inline Value& operator=(Value&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Value& default_instance();

  enum DatumCase {
    kValueInt = 2,
    kValueFloat = 3,
    kValueDouble = 4,
    kValueString = 5,
    kValueBytes = 6,
    DATUM_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Value* internal_default_instance() {
    return reinterpret_cast<const Value*>(
               &_Value_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Value& a, Value& b) {
    a.Swap(&b);
  }
  inline void Swap(Value* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Value* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Value* New() const final {
    return CreateMaybeMessage<Value>(nullptr);
  }

  Value* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Value>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Value& from);
  void MergeFrom(const Value& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Value* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "OpenLogReplicator.pb.Value";
  }
  protected:
  explicit Value(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_OraProtoBuf_2eproto);
    return ::descriptor_table_OraProtoBuf_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kValueIntFieldNumber = 2,
    kValueFloatFieldNumber = 3,
    kValueDoubleFieldNumber = 4,
    kValueStringFieldNumber = 5,
    kValueBytesFieldNumber = 6,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // int64 value_int = 2;
  private:
  bool _internal_has_value_int() const;
  public:
  void clear_value_int();
  ::PROTOBUF_NAMESPACE_ID::int64 value_int() const;
  void set_value_int(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_value_int() const;
  void _internal_set_value_int(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // float value_float = 3;
  private:
  bool _internal_has_value_float() const;
  public:
  void clear_value_float();
  float value_float() const;
  void set_value_float(float value);
  private:
  float _internal_value_float() const;
  void _internal_set_value_float(float value);
  public:

  // double value_double = 4;
  private:
  bool _internal_has_value_double() const;
  public:
  void clear_value_double();
  double value_double() const;
  void set_value_double(double value);
  private:
  double _internal_value_double() const;
  void _internal_set_value_double(double value);
  public:

  // string value_string = 5;
  private:
  bool _internal_has_value_string() const;
  public:
  void clear_value_string();
  const std::string& value_string() const;
  void set_value_string(const std::string& value);
  void set_value_string(std::string&& value);
  void set_value_string(const char* value);
  void set_value_string(const char* value, size_t size);
  std::string* mutable_value_string();
  std::string* release_value_string();
  void set_allocated_value_string(std::string* value_string);
  private:
  const std::string& _internal_value_string() const;
  void _internal_set_value_string(const std::string& value);
  std::string* _internal_mutable_value_string();
  public:

  // bytes value_bytes = 6;
  private:
  bool _internal_has_value_bytes() const;
  public:
  void clear_value_bytes();
  const std::string& value_bytes() const;
  void set_value_bytes(const std::string& value);
  void set_value_bytes(std::string&& value);
  void set_value_bytes(const char* value);
  void set_value_bytes(const void* value, size_t size);
  std::string* mutable_value_bytes();
  std::string* release_value_bytes();
  void set_allocated_value_bytes(std::string* value_bytes);
  private:
  const std::string& _internal_value_bytes() const;
  void _internal_set_value_bytes(const std::string& value);
  std::string* _internal_mutable_value_bytes();
  public:

  void clear_datum();
  DatumCase datum_case() const;
  // @@protoc_insertion_point(class_scope:OpenLogReplicator.pb.Value)
 private:
  class _Internal;
  void set_has_value_int();
  void set_has_value_float();
  void set_has_value_double();
  void set_has_value_string();
  void set_has_value_bytes();

  inline bool has_datum() const;
  inline void clear_has_datum();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  union DatumUnion {
    DatumUnion() {}
    ::PROTOBUF_NAMESPACE_ID::int64 value_int_;
    float value_float_;
    double value_double_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_string_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_bytes_;
  } datum_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_OraProtoBuf_2eproto;
};
// -------------------------------------------------------------------

class Column PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:OpenLogReplicator.pb.Column) */ {
 public:
  inline Column() : Column(nullptr) {}
  virtual ~Column();

  Column(const Column& from);
  Column(Column&& from) noexcept
    : Column() {
    *this = ::std::move(from);
  }

  inline Column& operator=(const Column& from) {
    CopyFrom(from);
    return *this;
  }
  inline Column& operator=(Column&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Column& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Column* internal_default_instance() {
    return reinterpret_cast<const Column*>(
               &_Column_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Column& a, Column& b) {
    a.Swap(&b);
  }
  inline void Swap(Column* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Column* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Column* New() const final {
    return CreateMaybeMessage<Column>(nullptr);
  }

  Column* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Column>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Column& from);
  void MergeFrom(const Column& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Column* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "OpenLogReplicator.pb.Column";
  }
  protected:
  explicit Column(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_OraProtoBuf_2eproto);
    return ::descriptor_table_OraProtoBuf_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kTypeFieldNumber = 2,
    kLengthFieldNumber = 3,
    kPrecisionFieldNumber = 4,
    kScaleFieldNumber = 5,
    kNullableFieldNumber = 6,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .OpenLogReplicator.pb.ColumnType type = 2;
  void clear_type();
  ::OpenLogReplicator::pb::ColumnType type() const;
  void set_type(::OpenLogReplicator::pb::ColumnType value);
  private:
  ::OpenLogReplicator::pb::ColumnType _internal_type() const;
  void _internal_set_type(::OpenLogReplicator::pb::ColumnType value);
  public:

  // int32 length = 3;
  void clear_length();
  ::PROTOBUF_NAMESPACE_ID::int32 length() const;
  void set_length(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_length() const;
  void _internal_set_length(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 precision = 4;
  void clear_precision();
  ::PROTOBUF_NAMESPACE_ID::int32 precision() const;
  void set_precision(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_precision() const;
  void _internal_set_precision(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 scale = 5;
  void clear_scale();
  ::PROTOBUF_NAMESPACE_ID::int32 scale() const;
  void set_scale(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_scale() const;
  void _internal_set_scale(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // bool nullable = 6;
  void clear_nullable();
  bool nullable() const;
  void set_nullable(bool value);
  private:
  bool _internal_nullable() const;
  void _internal_set_nullable(bool value);
  public:

  // @@protoc_insertion_point(class_scope:OpenLogReplicator.pb.Column)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  int type_;
  ::PROTOBUF_NAMESPACE_ID::int32 length_;
  ::PROTOBUF_NAMESPACE_ID::int32 precision_;
  ::PROTOBUF_NAMESPACE_ID::int32 scale_;
  bool nullable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_OraProtoBuf_2eproto;
};
// -------------------------------------------------------------------

class Schema PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:OpenLogReplicator.pb.Schema) */ {
 public:
  inline Schema() : Schema(nullptr) {}
  virtual ~Schema();

  Schema(const Schema& from);
  Schema(Schema&& from) noexcept
    : Schema() {
    *this = ::std::move(from);
  }

  inline Schema& operator=(const Schema& from) {
    CopyFrom(from);
    return *this;
  }
  inline Schema& operator=(Schema&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Schema& default_instance();

  enum TmValCase {
    kTm = 4,
    kTms = 5,
    TM_VAL_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Schema* internal_default_instance() {
    return reinterpret_cast<const Schema*>(
               &_Schema_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Schema& a, Schema& b) {
    a.Swap(&b);
  }
  inline void Swap(Schema* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Schema* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Schema* New() const final {
    return CreateMaybeMessage<Schema>(nullptr);
  }

  Schema* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Schema>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Schema& from);
  void MergeFrom(const Schema& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Schema* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "OpenLogReplicator.pb.Schema";
  }
  protected:
  explicit Schema(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_OraProtoBuf_2eproto);
    return ::descriptor_table_OraProtoBuf_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kColumnFieldNumber = 6,
    kOwnerFieldNumber = 1,
    kNameFieldNumber = 2,
    kObjFieldNumber = 3,
    kTmFieldNumber = 4,
    kTmsFieldNumber = 5,
  };
  // repeated .OpenLogReplicator.pb.Column column = 6;
  int column_size() const;
  private:
  int _internal_column_size() const;
  public:
  void clear_column();
  ::OpenLogReplicator::pb::Column* mutable_column(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::OpenLogReplicator::pb::Column >*
      mutable_column();
  private:
  const ::OpenLogReplicator::pb::Column& _internal_column(int index) const;
  ::OpenLogReplicator::pb::Column* _internal_add_column();
  public:
  const ::OpenLogReplicator::pb::Column& column(int index) const;
  ::OpenLogReplicator::pb::Column* add_column();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::OpenLogReplicator::pb::Column >&
      column() const;

  // string owner = 1;
  void clear_owner();
  const std::string& owner() const;
  void set_owner(const std::string& value);
  void set_owner(std::string&& value);
  void set_owner(const char* value);
  void set_owner(const char* value, size_t size);
  std::string* mutable_owner();
  std::string* release_owner();
  void set_allocated_owner(std::string* owner);
  private:
  const std::string& _internal_owner() const;
  void _internal_set_owner(const std::string& value);
  std::string* _internal_mutable_owner();
  public:

  // string name = 2;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // uint32 obj = 3;
  void clear_obj();
  ::PROTOBUF_NAMESPACE_ID::uint32 obj() const;
  void set_obj(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_obj() const;
  void _internal_set_obj(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint64 tm = 4;
  private:
  bool _internal_has_tm() const;
  public:
  void clear_tm();
  ::PROTOBUF_NAMESPACE_ID::uint64 tm() const;
  void set_tm(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_tm() const;
  void _internal_set_tm(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // string tms = 5;
  private:
  bool _internal_has_tms() const;
  public:
  void clear_tms();
  const std::string& tms() const;
  void set_tms(const std::string& value);
  void set_tms(std::string&& value);
  void set_tms(const char* value);
  void set_tms(const char* value, size_t size);
  std::string* mutable_tms();
  std::string* release_tms();
  void set_allocated_tms(std::string* tms);
  private:
  const std::string& _internal_tms() const;
  void _internal_set_tms(const std::string& value);
  std::string* _internal_mutable_tms();
  public:

  void clear_tm_val();
  TmValCase tm_val_case() const;
  // @@protoc_insertion_point(class_scope:OpenLogReplicator.pb.Schema)
 private:
  class _Internal;
  void set_has_tm();
  void set_has_tms();

  inline bool has_tm_val() const;
  inline void clear_has_tm_val();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::OpenLogReplicator::pb::Column > column_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr owner_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::uint32 obj_;
  union TmValUnion {
    TmValUnion() {}
    ::PROTOBUF_NAMESPACE_ID::uint64 tm_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tms_;
  } tm_val_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_OraProtoBuf_2eproto;
};
// -------------------------------------------------------------------

class Payload PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:OpenLogReplicator.pb.Payload) */ {
 public:
  inline Payload() : Payload(nullptr) {}
  virtual ~Payload();

  Payload(const Payload& from);
  Payload(Payload&& from) noexcept
    : Payload() {
    *this = ::std::move(from);
  }

  inline Payload& operator=(const Payload& from) {
    CopyFrom(from);
    return *this;
  }
  inline Payload& operator=(Payload&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Payload& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Payload* internal_default_instance() {
    return reinterpret_cast<const Payload*>(
               &_Payload_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Payload& a, Payload& b) {
    a.Swap(&b);
  }
  inline void Swap(Payload* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Payload* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Payload* New() const final {
    return CreateMaybeMessage<Payload>(nullptr);
  }

  Payload* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Payload>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Payload& from);
  void MergeFrom(const Payload& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Payload* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "OpenLogReplicator.pb.Payload";
  }
  protected:
  explicit Payload(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_OraProtoBuf_2eproto);
    return ::descriptor_table_OraProtoBuf_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBeforeFieldNumber = 4,
    kAfterFieldNumber = 5,
    kRidFieldNumber = 3,
    kDdlFieldNumber = 6,
    kSchemaFieldNumber = 2,
    kOpFieldNumber = 1,
  };
  // repeated .OpenLogReplicator.pb.Value before = 4;
  int before_size() const;
  private:
  int _internal_before_size() const;
  public:
  void clear_before();
  ::OpenLogReplicator::pb::Value* mutable_before(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::OpenLogReplicator::pb::Value >*
      mutable_before();
  private:
  const ::OpenLogReplicator::pb::Value& _internal_before(int index) const;
  ::OpenLogReplicator::pb::Value* _internal_add_before();
  public:
  const ::OpenLogReplicator::pb::Value& before(int index) const;
  ::OpenLogReplicator::pb::Value* add_before();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::OpenLogReplicator::pb::Value >&
      before() const;

  // repeated .OpenLogReplicator.pb.Value after = 5;
  int after_size() const;
  private:
  int _internal_after_size() const;
  public:
  void clear_after();
  ::OpenLogReplicator::pb::Value* mutable_after(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::OpenLogReplicator::pb::Value >*
      mutable_after();
  private:
  const ::OpenLogReplicator::pb::Value& _internal_after(int index) const;
  ::OpenLogReplicator::pb::Value* _internal_add_after();
  public:
  const ::OpenLogReplicator::pb::Value& after(int index) const;
  ::OpenLogReplicator::pb::Value* add_after();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::OpenLogReplicator::pb::Value >&
      after() const;

  // string rid = 3;
  void clear_rid();
  const std::string& rid() const;
  void set_rid(const std::string& value);
  void set_rid(std::string&& value);
  void set_rid(const char* value);
  void set_rid(const char* value, size_t size);
  std::string* mutable_rid();
  std::string* release_rid();
  void set_allocated_rid(std::string* rid);
  private:
  const std::string& _internal_rid() const;
  void _internal_set_rid(const std::string& value);
  std::string* _internal_mutable_rid();
  public:

  // string ddl = 6;
  void clear_ddl();
  const std::string& ddl() const;
  void set_ddl(const std::string& value);
  void set_ddl(std::string&& value);
  void set_ddl(const char* value);
  void set_ddl(const char* value, size_t size);
  std::string* mutable_ddl();
  std::string* release_ddl();
  void set_allocated_ddl(std::string* ddl);
  private:
  const std::string& _internal_ddl() const;
  void _internal_set_ddl(const std::string& value);
  std::string* _internal_mutable_ddl();
  public:

  // .OpenLogReplicator.pb.Schema schema = 2;
  bool has_schema() const;
  private:
  bool _internal_has_schema() const;
  public:
  void clear_schema();
  const ::OpenLogReplicator::pb::Schema& schema() const;
  ::OpenLogReplicator::pb::Schema* release_schema();
  ::OpenLogReplicator::pb::Schema* mutable_schema();
  void set_allocated_schema(::OpenLogReplicator::pb::Schema* schema);
  private:
  const ::OpenLogReplicator::pb::Schema& _internal_schema() const;
  ::OpenLogReplicator::pb::Schema* _internal_mutable_schema();
  public:
  void unsafe_arena_set_allocated_schema(
      ::OpenLogReplicator::pb::Schema* schema);
  ::OpenLogReplicator::pb::Schema* unsafe_arena_release_schema();

  // .OpenLogReplicator.pb.Op op = 1;
  void clear_op();
  ::OpenLogReplicator::pb::Op op() const;
  void set_op(::OpenLogReplicator::pb::Op value);
  private:
  ::OpenLogReplicator::pb::Op _internal_op() const;
  void _internal_set_op(::OpenLogReplicator::pb::Op value);
  public:

  // @@protoc_insertion_point(class_scope:OpenLogReplicator.pb.Payload)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::OpenLogReplicator::pb::Value > before_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::OpenLogReplicator::pb::Value > after_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr rid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ddl_;
  ::OpenLogReplicator::pb::Schema* schema_;
  int op_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_OraProtoBuf_2eproto;
};
// -------------------------------------------------------------------

class SchemaRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:OpenLogReplicator.pb.SchemaRequest) */ {
 public:
  inline SchemaRequest() : SchemaRequest(nullptr) {}
  virtual ~SchemaRequest();

  SchemaRequest(const SchemaRequest& from);
  SchemaRequest(SchemaRequest&& from) noexcept
    : SchemaRequest() {
    *this = ::std::move(from);
  }

  inline SchemaRequest& operator=(const SchemaRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SchemaRequest& operator=(SchemaRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SchemaRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SchemaRequest* internal_default_instance() {
    return reinterpret_cast<const SchemaRequest*>(
               &_SchemaRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(SchemaRequest& a, SchemaRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SchemaRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SchemaRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SchemaRequest* New() const final {
    return CreateMaybeMessage<SchemaRequest>(nullptr);
  }

  SchemaRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SchemaRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SchemaRequest& from);
  void MergeFrom(const SchemaRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SchemaRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "OpenLogReplicator.pb.SchemaRequest";
  }
  protected:
  explicit SchemaRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_OraProtoBuf_2eproto);
    return ::descriptor_table_OraProtoBuf_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMaskFieldNumber = 1,
    kFilterFieldNumber = 2,
  };
  // string mask = 1;
  void clear_mask();
  const std::string& mask() const;
  void set_mask(const std::string& value);
  void set_mask(std::string&& value);
  void set_mask(const char* value);
  void set_mask(const char* value, size_t size);
  std::string* mutable_mask();
  std::string* release_mask();
  void set_allocated_mask(std::string* mask);
  private:
  const std::string& _internal_mask() const;
  void _internal_set_mask(const std::string& value);
  std::string* _internal_mutable_mask();
  public:

  // string filter = 2;
  void clear_filter();
  const std::string& filter() const;
  void set_filter(const std::string& value);
  void set_filter(std::string&& value);
  void set_filter(const char* value);
  void set_filter(const char* value, size_t size);
  std::string* mutable_filter();
  std::string* release_filter();
  void set_allocated_filter(std::string* filter);
  private:
  const std::string& _internal_filter() const;
  void _internal_set_filter(const std::string& value);
  std::string* _internal_mutable_filter();
  public:

  // @@protoc_insertion_point(class_scope:OpenLogReplicator.pb.SchemaRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mask_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr filter_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_OraProtoBuf_2eproto;
};
// -------------------------------------------------------------------

class RedoRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:OpenLogReplicator.pb.RedoRequest) */ {
 public:
  inline RedoRequest() : RedoRequest(nullptr) {}
  virtual ~RedoRequest();

  RedoRequest(const RedoRequest& from);
  RedoRequest(RedoRequest&& from) noexcept
    : RedoRequest() {
    *this = ::std::move(from);
  }

  inline RedoRequest& operator=(const RedoRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RedoRequest& operator=(RedoRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RedoRequest& default_instance();

  enum TmValCase {
    kScn = 3,
    kSeq = 4,
    kTms = 5,
    kTmRel = 6,
    TM_VAL_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RedoRequest* internal_default_instance() {
    return reinterpret_cast<const RedoRequest*>(
               &_RedoRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(RedoRequest& a, RedoRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RedoRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RedoRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RedoRequest* New() const final {
    return CreateMaybeMessage<RedoRequest>(nullptr);
  }

  RedoRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RedoRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RedoRequest& from);
  void MergeFrom(const RedoRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RedoRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "OpenLogReplicator.pb.RedoRequest";
  }
  protected:
  explicit RedoRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_OraProtoBuf_2eproto);
    return ::descriptor_table_OraProtoBuf_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSchemaFieldNumber = 7,
    kDatabaseNameFieldNumber = 2,
    kCodeFieldNumber = 1,
    kScnFieldNumber = 3,
    kSeqFieldNumber = 4,
    kTmsFieldNumber = 5,
    kTmRelFieldNumber = 6,
  };
  // repeated .OpenLogReplicator.pb.SchemaRequest schema = 7;
  int schema_size() const;
  private:
  int _internal_schema_size() const;
  public:
  void clear_schema();
  ::OpenLogReplicator::pb::SchemaRequest* mutable_schema(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::OpenLogReplicator::pb::SchemaRequest >*
      mutable_schema();
  private:
  const ::OpenLogReplicator::pb::SchemaRequest& _internal_schema(int index) const;
  ::OpenLogReplicator::pb::SchemaRequest* _internal_add_schema();
  public:
  const ::OpenLogReplicator::pb::SchemaRequest& schema(int index) const;
  ::OpenLogReplicator::pb::SchemaRequest* add_schema();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::OpenLogReplicator::pb::SchemaRequest >&
      schema() const;

  // string database_name = 2;
  void clear_database_name();
  const std::string& database_name() const;
  void set_database_name(const std::string& value);
  void set_database_name(std::string&& value);
  void set_database_name(const char* value);
  void set_database_name(const char* value, size_t size);
  std::string* mutable_database_name();
  std::string* release_database_name();
  void set_allocated_database_name(std::string* database_name);
  private:
  const std::string& _internal_database_name() const;
  void _internal_set_database_name(const std::string& value);
  std::string* _internal_mutable_database_name();
  public:

  // .OpenLogReplicator.pb.RequestCode code = 1;
  void clear_code();
  ::OpenLogReplicator::pb::RequestCode code() const;
  void set_code(::OpenLogReplicator::pb::RequestCode value);
  private:
  ::OpenLogReplicator::pb::RequestCode _internal_code() const;
  void _internal_set_code(::OpenLogReplicator::pb::RequestCode value);
  public:

  // uint64 scn = 3;
  private:
  bool _internal_has_scn() const;
  public:
  void clear_scn();
  ::PROTOBUF_NAMESPACE_ID::uint64 scn() const;
  void set_scn(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_scn() const;
  void _internal_set_scn(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 seq = 4;
  private:
  bool _internal_has_seq() const;
  public:
  void clear_seq();
  ::PROTOBUF_NAMESPACE_ID::uint64 seq() const;
  void set_seq(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_seq() const;
  void _internal_set_seq(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // string tms = 5;
  private:
  bool _internal_has_tms() const;
  public:
  void clear_tms();
  const std::string& tms() const;
  void set_tms(const std::string& value);
  void set_tms(std::string&& value);
  void set_tms(const char* value);
  void set_tms(const char* value, size_t size);
  std::string* mutable_tms();
  std::string* release_tms();
  void set_allocated_tms(std::string* tms);
  private:
  const std::string& _internal_tms() const;
  void _internal_set_tms(const std::string& value);
  std::string* _internal_mutable_tms();
  public:

  // int64 tm_rel = 6;
  private:
  bool _internal_has_tm_rel() const;
  public:
  void clear_tm_rel();
  ::PROTOBUF_NAMESPACE_ID::int64 tm_rel() const;
  void set_tm_rel(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_tm_rel() const;
  void _internal_set_tm_rel(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  void clear_tm_val();
  TmValCase tm_val_case() const;
  // @@protoc_insertion_point(class_scope:OpenLogReplicator.pb.RedoRequest)
 private:
  class _Internal;
  void set_has_scn();
  void set_has_seq();
  void set_has_tms();
  void set_has_tm_rel();

  inline bool has_tm_val() const;
  inline void clear_has_tm_val();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::OpenLogReplicator::pb::SchemaRequest > schema_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr database_name_;
  int code_;
  union TmValUnion {
    TmValUnion() {}
    ::PROTOBUF_NAMESPACE_ID::uint64 scn_;
    ::PROTOBUF_NAMESPACE_ID::uint64 seq_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tms_;
    ::PROTOBUF_NAMESPACE_ID::int64 tm_rel_;
  } tm_val_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_OraProtoBuf_2eproto;
};
// -------------------------------------------------------------------

class RedoResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:OpenLogReplicator.pb.RedoResponse) */ {
 public:
  inline RedoResponse() : RedoResponse(nullptr) {}
  virtual ~RedoResponse();

  RedoResponse(const RedoResponse& from);
  RedoResponse(RedoResponse&& from) noexcept
    : RedoResponse() {
    *this = ::std::move(from);
  }

  inline RedoResponse& operator=(const RedoResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RedoResponse& operator=(RedoResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RedoResponse& default_instance();

  enum ScnValCase {
    kScn = 2,
    kScns = 3,
    SCN_VAL_NOT_SET = 0,
  };

  enum TmValCase {
    kTm = 4,
    kTms = 5,
    TM_VAL_NOT_SET = 0,
  };

  enum XidValCase {
    kXid = 6,
    kXidn = 7,
    XID_VAL_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RedoResponse* internal_default_instance() {
    return reinterpret_cast<const RedoResponse*>(
               &_RedoResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(RedoResponse& a, RedoResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RedoResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RedoResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RedoResponse* New() const final {
    return CreateMaybeMessage<RedoResponse>(nullptr);
  }

  RedoResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RedoResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RedoResponse& from);
  void MergeFrom(const RedoResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RedoResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "OpenLogReplicator.pb.RedoResponse";
  }
  protected:
  explicit RedoResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_OraProtoBuf_2eproto);
    return ::descriptor_table_OraProtoBuf_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPayloadFieldNumber = 8,
    kCodeFieldNumber = 1,
    kScnFieldNumber = 2,
    kScnsFieldNumber = 3,
    kTmFieldNumber = 4,
    kTmsFieldNumber = 5,
    kXidFieldNumber = 6,
    kXidnFieldNumber = 7,
  };
  // repeated .OpenLogReplicator.pb.Payload payload = 8;
  int payload_size() const;
  private:
  int _internal_payload_size() const;
  public:
  void clear_payload();
  ::OpenLogReplicator::pb::Payload* mutable_payload(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::OpenLogReplicator::pb::Payload >*
      mutable_payload();
  private:
  const ::OpenLogReplicator::pb::Payload& _internal_payload(int index) const;
  ::OpenLogReplicator::pb::Payload* _internal_add_payload();
  public:
  const ::OpenLogReplicator::pb::Payload& payload(int index) const;
  ::OpenLogReplicator::pb::Payload* add_payload();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::OpenLogReplicator::pb::Payload >&
      payload() const;

  // .OpenLogReplicator.pb.ResponseCode code = 1;
  void clear_code();
  ::OpenLogReplicator::pb::ResponseCode code() const;
  void set_code(::OpenLogReplicator::pb::ResponseCode value);
  private:
  ::OpenLogReplicator::pb::ResponseCode _internal_code() const;
  void _internal_set_code(::OpenLogReplicator::pb::ResponseCode value);
  public:

  // uint64 scn = 2;
  private:
  bool _internal_has_scn() const;
  public:
  void clear_scn();
  ::PROTOBUF_NAMESPACE_ID::uint64 scn() const;
  void set_scn(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_scn() const;
  void _internal_set_scn(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // string scns = 3;
  private:
  bool _internal_has_scns() const;
  public:
  void clear_scns();
  const std::string& scns() const;
  void set_scns(const std::string& value);
  void set_scns(std::string&& value);
  void set_scns(const char* value);
  void set_scns(const char* value, size_t size);
  std::string* mutable_scns();
  std::string* release_scns();
  void set_allocated_scns(std::string* scns);
  private:
  const std::string& _internal_scns() const;
  void _internal_set_scns(const std::string& value);
  std::string* _internal_mutable_scns();
  public:

  // uint64 tm = 4;
  private:
  bool _internal_has_tm() const;
  public:
  void clear_tm();
  ::PROTOBUF_NAMESPACE_ID::uint64 tm() const;
  void set_tm(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_tm() const;
  void _internal_set_tm(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // string tms = 5;
  private:
  bool _internal_has_tms() const;
  public:
  void clear_tms();
  const std::string& tms() const;
  void set_tms(const std::string& value);
  void set_tms(std::string&& value);
  void set_tms(const char* value);
  void set_tms(const char* value, size_t size);
  std::string* mutable_tms();
  std::string* release_tms();
  void set_allocated_tms(std::string* tms);
  private:
  const std::string& _internal_tms() const;
  void _internal_set_tms(const std::string& value);
  std::string* _internal_mutable_tms();
  public:

  // string xid = 6;
  private:
  bool _internal_has_xid() const;
  public:
  void clear_xid();
  const std::string& xid() const;
  void set_xid(const std::string& value);
  void set_xid(std::string&& value);
  void set_xid(const char* value);
  void set_xid(const char* value, size_t size);
  std::string* mutable_xid();
  std::string* release_xid();
  void set_allocated_xid(std::string* xid);
  private:
  const std::string& _internal_xid() const;
  void _internal_set_xid(const std::string& value);
  std::string* _internal_mutable_xid();
  public:

  // uint64 xidn = 7;
  private:
  bool _internal_has_xidn() const;
  public:
  void clear_xidn();
  ::PROTOBUF_NAMESPACE_ID::uint64 xidn() const;
  void set_xidn(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_xidn() const;
  void _internal_set_xidn(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  void clear_scn_val();
  ScnValCase scn_val_case() const;
  void clear_tm_val();
  TmValCase tm_val_case() const;
  void clear_xid_val();
  XidValCase xid_val_case() const;
  // @@protoc_insertion_point(class_scope:OpenLogReplicator.pb.RedoResponse)
 private:
  class _Internal;
  void set_has_scn();
  void set_has_scns();
  void set_has_tm();
  void set_has_tms();
  void set_has_xid();
  void set_has_xidn();

  inline bool has_scn_val() const;
  inline void clear_has_scn_val();

  inline bool has_tm_val() const;
  inline void clear_has_tm_val();

  inline bool has_xid_val() const;
  inline void clear_has_xid_val();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::OpenLogReplicator::pb::Payload > payload_;
  int code_;
  union ScnValUnion {
    ScnValUnion() {}
    ::PROTOBUF_NAMESPACE_ID::uint64 scn_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr scns_;
  } scn_val_;
  union TmValUnion {
    TmValUnion() {}
    ::PROTOBUF_NAMESPACE_ID::uint64 tm_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tms_;
  } tm_val_;
  union XidValUnion {
    XidValUnion() {}
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr xid_;
    ::PROTOBUF_NAMESPACE_ID::uint64 xidn_;
  } xid_val_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[3];

  friend struct ::TableStruct_OraProtoBuf_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Value

// string name = 1;
inline void Value::clear_name() {
  name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Value::name() const {
  // @@protoc_insertion_point(field_get:OpenLogReplicator.pb.Value.name)
  return _internal_name();
}
inline void Value::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:OpenLogReplicator.pb.Value.name)
}
inline std::string* Value::mutable_name() {
  // @@protoc_insertion_point(field_mutable:OpenLogReplicator.pb.Value.name)
  return _internal_mutable_name();
}
inline const std::string& Value::_internal_name() const {
  return name_.Get();
}
inline void Value::_internal_set_name(const std::string& value) {
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Value::set_name(std::string&& value) {
  
  name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:OpenLogReplicator.pb.Value.name)
}
inline void Value::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:OpenLogReplicator.pb.Value.name)
}
inline void Value::set_name(const char* value,
    size_t size) {
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:OpenLogReplicator.pb.Value.name)
}
inline std::string* Value::_internal_mutable_name() {
  
  return name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Value::release_name() {
  // @@protoc_insertion_point(field_release:OpenLogReplicator.pb.Value.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Value::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:OpenLogReplicator.pb.Value.name)
}

// int64 value_int = 2;
inline bool Value::_internal_has_value_int() const {
  return datum_case() == kValueInt;
}
inline void Value::set_has_value_int() {
  _oneof_case_[0] = kValueInt;
}
inline void Value::clear_value_int() {
  if (_internal_has_value_int()) {
    datum_.value_int_ = PROTOBUF_LONGLONG(0);
    clear_has_datum();
  }
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Value::_internal_value_int() const {
  if (_internal_has_value_int()) {
    return datum_.value_int_;
  }
  return PROTOBUF_LONGLONG(0);
}
inline void Value::_internal_set_value_int(::PROTOBUF_NAMESPACE_ID::int64 value) {
  if (!_internal_has_value_int()) {
    clear_datum();
    set_has_value_int();
  }
  datum_.value_int_ = value;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Value::value_int() const {
  // @@protoc_insertion_point(field_get:OpenLogReplicator.pb.Value.value_int)
  return _internal_value_int();
}
inline void Value::set_value_int(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_value_int(value);
  // @@protoc_insertion_point(field_set:OpenLogReplicator.pb.Value.value_int)
}

// float value_float = 3;
inline bool Value::_internal_has_value_float() const {
  return datum_case() == kValueFloat;
}
inline void Value::set_has_value_float() {
  _oneof_case_[0] = kValueFloat;
}
inline void Value::clear_value_float() {
  if (_internal_has_value_float()) {
    datum_.value_float_ = 0;
    clear_has_datum();
  }
}
inline float Value::_internal_value_float() const {
  if (_internal_has_value_float()) {
    return datum_.value_float_;
  }
  return 0;
}
inline void Value::_internal_set_value_float(float value) {
  if (!_internal_has_value_float()) {
    clear_datum();
    set_has_value_float();
  }
  datum_.value_float_ = value;
}
inline float Value::value_float() const {
  // @@protoc_insertion_point(field_get:OpenLogReplicator.pb.Value.value_float)
  return _internal_value_float();
}
inline void Value::set_value_float(float value) {
  _internal_set_value_float(value);
  // @@protoc_insertion_point(field_set:OpenLogReplicator.pb.Value.value_float)
}

// double value_double = 4;
inline bool Value::_internal_has_value_double() const {
  return datum_case() == kValueDouble;
}
inline void Value::set_has_value_double() {
  _oneof_case_[0] = kValueDouble;
}
inline void Value::clear_value_double() {
  if (_internal_has_value_double()) {
    datum_.value_double_ = 0;
    clear_has_datum();
  }
}
inline double Value::_internal_value_double() const {
  if (_internal_has_value_double()) {
    return datum_.value_double_;
  }
  return 0;
}
inline void Value::_internal_set_value_double(double value) {
  if (!_internal_has_value_double()) {
    clear_datum();
    set_has_value_double();
  }
  datum_.value_double_ = value;
}
inline double Value::value_double() const {
  // @@protoc_insertion_point(field_get:OpenLogReplicator.pb.Value.value_double)
  return _internal_value_double();
}
inline void Value::set_value_double(double value) {
  _internal_set_value_double(value);
  // @@protoc_insertion_point(field_set:OpenLogReplicator.pb.Value.value_double)
}

// string value_string = 5;
inline bool Value::_internal_has_value_string() const {
  return datum_case() == kValueString;
}
inline void Value::set_has_value_string() {
  _oneof_case_[0] = kValueString;
}
inline void Value::clear_value_string() {
  if (_internal_has_value_string()) {
    datum_.value_string_.Destroy(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
    clear_has_datum();
  }
}
inline const std::string& Value::value_string() const {
  // @@protoc_insertion_point(field_get:OpenLogReplicator.pb.Value.value_string)
  return _internal_value_string();
}
inline void Value::set_value_string(const std::string& value) {
  _internal_set_value_string(value);
  // @@protoc_insertion_point(field_set:OpenLogReplicator.pb.Value.value_string)
}
inline std::string* Value::mutable_value_string() {
  // @@protoc_insertion_point(field_mutable:OpenLogReplicator.pb.Value.value_string)
  return _internal_mutable_value_string();
}
inline const std::string& Value::_internal_value_string() const {
  if (_internal_has_value_string()) {
    return datum_.value_string_.Get();
  }
  return *&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void Value::_internal_set_value_string(const std::string& value) {
  if (!_internal_has_value_string()) {
    clear_datum();
    set_has_value_string();
    datum_.value_string_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  datum_.value_string_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Value::set_value_string(std::string&& value) {
  // @@protoc_insertion_point(field_set:OpenLogReplicator.pb.Value.value_string)
  if (!_internal_has_value_string()) {
    clear_datum();
    set_has_value_string();
    datum_.value_string_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  datum_.value_string_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:OpenLogReplicator.pb.Value.value_string)
}
inline void Value::set_value_string(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  if (!_internal_has_value_string()) {
    clear_datum();
    set_has_value_string();
    datum_.value_string_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  datum_.value_string_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:OpenLogReplicator.pb.Value.value_string)
}
inline void Value::set_value_string(const char* value,
                             size_t size) {
  if (!_internal_has_value_string()) {
    clear_datum();
    set_has_value_string();
    datum_.value_string_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  datum_.value_string_.Set(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size),
      GetArena());
  // @@protoc_insertion_point(field_set_pointer:OpenLogReplicator.pb.Value.value_string)
}
inline std::string* Value::_internal_mutable_value_string() {
  if (!_internal_has_value_string()) {
    clear_datum();
    set_has_value_string();
    datum_.value_string_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return datum_.value_string_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Value::release_value_string() {
  // @@protoc_insertion_point(field_release:OpenLogReplicator.pb.Value.value_string)
  if (_internal_has_value_string()) {
    clear_has_datum();
    return datum_.value_string_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  } else {
    return nullptr;
  }
}
inline void Value::set_allocated_value_string(std::string* value_string) {
  if (has_datum()) {
    clear_datum();
  }
  if (value_string != nullptr) {
    set_has_value_string();
    datum_.value_string_.UnsafeSetDefault(value_string);
    ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena();
    if (arena != nullptr) {
      arena->Own(value_string);
    }
  }
  // @@protoc_insertion_point(field_set_allocated:OpenLogReplicator.pb.Value.value_string)
}

// bytes value_bytes = 6;
inline bool Value::_internal_has_value_bytes() const {
  return datum_case() == kValueBytes;
}
inline void Value::set_has_value_bytes() {
  _oneof_case_[0] = kValueBytes;
}
inline void Value::clear_value_bytes() {
  if (_internal_has_value_bytes()) {
    datum_.value_bytes_.Destroy(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
    clear_has_datum();
  }
}
inline const std::string& Value::value_bytes() const {
  // @@protoc_insertion_point(field_get:OpenLogReplicator.pb.Value.value_bytes)
  return _internal_value_bytes();
}
inline void Value::set_value_bytes(const std::string& value) {
  _internal_set_value_bytes(value);
  // @@protoc_insertion_point(field_set:OpenLogReplicator.pb.Value.value_bytes)
}
inline std::string* Value::mutable_value_bytes() {
  // @@protoc_insertion_point(field_mutable:OpenLogReplicator.pb.Value.value_bytes)
  return _internal_mutable_value_bytes();
}
inline const std::string& Value::_internal_value_bytes() const {
  if (_internal_has_value_bytes()) {
    return datum_.value_bytes_.Get();
  }
  return *&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void Value::_internal_set_value_bytes(const std::string& value) {
  if (!_internal_has_value_bytes()) {
    clear_datum();
    set_has_value_bytes();
    datum_.value_bytes_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  datum_.value_bytes_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Value::set_value_bytes(std::string&& value) {
  // @@protoc_insertion_point(field_set:OpenLogReplicator.pb.Value.value_bytes)
  if (!_internal_has_value_bytes()) {
    clear_datum();
    set_has_value_bytes();
    datum_.value_bytes_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  datum_.value_bytes_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:OpenLogReplicator.pb.Value.value_bytes)
}
inline void Value::set_value_bytes(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  if (!_internal_has_value_bytes()) {
    clear_datum();
    set_has_value_bytes();
    datum_.value_bytes_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  datum_.value_bytes_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:OpenLogReplicator.pb.Value.value_bytes)
}
inline void Value::set_value_bytes(const void* value,
                             size_t size) {
  if (!_internal_has_value_bytes()) {
    clear_datum();
    set_has_value_bytes();
    datum_.value_bytes_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  datum_.value_bytes_.Set(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size),
      GetArena());
  // @@protoc_insertion_point(field_set_pointer:OpenLogReplicator.pb.Value.value_bytes)
}
inline std::string* Value::_internal_mutable_value_bytes() {
  if (!_internal_has_value_bytes()) {
    clear_datum();
    set_has_value_bytes();
    datum_.value_bytes_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return datum_.value_bytes_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Value::release_value_bytes() {
  // @@protoc_insertion_point(field_release:OpenLogReplicator.pb.Value.value_bytes)
  if (_internal_has_value_bytes()) {
    clear_has_datum();
    return datum_.value_bytes_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  } else {
    return nullptr;
  }
}
inline void Value::set_allocated_value_bytes(std::string* value_bytes) {
  if (has_datum()) {
    clear_datum();
  }
  if (value_bytes != nullptr) {
    set_has_value_bytes();
    datum_.value_bytes_.UnsafeSetDefault(value_bytes);
    ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena();
    if (arena != nullptr) {
      arena->Own(value_bytes);
    }
  }
  // @@protoc_insertion_point(field_set_allocated:OpenLogReplicator.pb.Value.value_bytes)
}

inline bool Value::has_datum() const {
  return datum_case() != DATUM_NOT_SET;
}
inline void Value::clear_has_datum() {
  _oneof_case_[0] = DATUM_NOT_SET;
}
inline Value::DatumCase Value::datum_case() const {
  return Value::DatumCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Column

// string name = 1;
inline void Column::clear_name() {
  name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Column::name() const {
  // @@protoc_insertion_point(field_get:OpenLogReplicator.pb.Column.name)
  return _internal_name();
}
inline void Column::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:OpenLogReplicator.pb.Column.name)
}
inline std::string* Column::mutable_name() {
  // @@protoc_insertion_point(field_mutable:OpenLogReplicator.pb.Column.name)
  return _internal_mutable_name();
}
inline const std::string& Column::_internal_name() const {
  return name_.Get();
}
inline void Column::_internal_set_name(const std::string& value) {
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Column::set_name(std::string&& value) {
  
  name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:OpenLogReplicator.pb.Column.name)
}
inline void Column::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:OpenLogReplicator.pb.Column.name)
}
inline void Column::set_name(const char* value,
    size_t size) {
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:OpenLogReplicator.pb.Column.name)
}
inline std::string* Column::_internal_mutable_name() {
  
  return name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Column::release_name() {
  // @@protoc_insertion_point(field_release:OpenLogReplicator.pb.Column.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Column::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:OpenLogReplicator.pb.Column.name)
}

// .OpenLogReplicator.pb.ColumnType type = 2;
inline void Column::clear_type() {
  type_ = 0;
}
inline ::OpenLogReplicator::pb::ColumnType Column::_internal_type() const {
  return static_cast< ::OpenLogReplicator::pb::ColumnType >(type_);
}
inline ::OpenLogReplicator::pb::ColumnType Column::type() const {
  // @@protoc_insertion_point(field_get:OpenLogReplicator.pb.Column.type)
  return _internal_type();
}
inline void Column::_internal_set_type(::OpenLogReplicator::pb::ColumnType value) {
  
  type_ = value;
}
inline void Column::set_type(::OpenLogReplicator::pb::ColumnType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:OpenLogReplicator.pb.Column.type)
}

// int32 length = 3;
inline void Column::clear_length() {
  length_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Column::_internal_length() const {
  return length_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Column::length() const {
  // @@protoc_insertion_point(field_get:OpenLogReplicator.pb.Column.length)
  return _internal_length();
}
inline void Column::_internal_set_length(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  length_ = value;
}
inline void Column::set_length(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_length(value);
  // @@protoc_insertion_point(field_set:OpenLogReplicator.pb.Column.length)
}

// int32 precision = 4;
inline void Column::clear_precision() {
  precision_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Column::_internal_precision() const {
  return precision_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Column::precision() const {
  // @@protoc_insertion_point(field_get:OpenLogReplicator.pb.Column.precision)
  return _internal_precision();
}
inline void Column::_internal_set_precision(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  precision_ = value;
}
inline void Column::set_precision(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_precision(value);
  // @@protoc_insertion_point(field_set:OpenLogReplicator.pb.Column.precision)
}

// int32 scale = 5;
inline void Column::clear_scale() {
  scale_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Column::_internal_scale() const {
  return scale_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Column::scale() const {
  // @@protoc_insertion_point(field_get:OpenLogReplicator.pb.Column.scale)
  return _internal_scale();
}
inline void Column::_internal_set_scale(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  scale_ = value;
}
inline void Column::set_scale(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_scale(value);
  // @@protoc_insertion_point(field_set:OpenLogReplicator.pb.Column.scale)
}

// bool nullable = 6;
inline void Column::clear_nullable() {
  nullable_ = false;
}
inline bool Column::_internal_nullable() const {
  return nullable_;
}
inline bool Column::nullable() const {
  // @@protoc_insertion_point(field_get:OpenLogReplicator.pb.Column.nullable)
  return _internal_nullable();
}
inline void Column::_internal_set_nullable(bool value) {
  
  nullable_ = value;
}
inline void Column::set_nullable(bool value) {
  _internal_set_nullable(value);
  // @@protoc_insertion_point(field_set:OpenLogReplicator.pb.Column.nullable)
}

// -------------------------------------------------------------------

// Schema

// string owner = 1;
inline void Schema::clear_owner() {
  owner_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Schema::owner() const {
  // @@protoc_insertion_point(field_get:OpenLogReplicator.pb.Schema.owner)
  return _internal_owner();
}
inline void Schema::set_owner(const std::string& value) {
  _internal_set_owner(value);
  // @@protoc_insertion_point(field_set:OpenLogReplicator.pb.Schema.owner)
}
inline std::string* Schema::mutable_owner() {
  // @@protoc_insertion_point(field_mutable:OpenLogReplicator.pb.Schema.owner)
  return _internal_mutable_owner();
}
inline const std::string& Schema::_internal_owner() const {
  return owner_.Get();
}
inline void Schema::_internal_set_owner(const std::string& value) {
  
  owner_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Schema::set_owner(std::string&& value) {
  
  owner_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:OpenLogReplicator.pb.Schema.owner)
}
inline void Schema::set_owner(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  owner_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:OpenLogReplicator.pb.Schema.owner)
}
inline void Schema::set_owner(const char* value,
    size_t size) {
  
  owner_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:OpenLogReplicator.pb.Schema.owner)
}
inline std::string* Schema::_internal_mutable_owner() {
  
  return owner_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Schema::release_owner() {
  // @@protoc_insertion_point(field_release:OpenLogReplicator.pb.Schema.owner)
  return owner_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Schema::set_allocated_owner(std::string* owner) {
  if (owner != nullptr) {
    
  } else {
    
  }
  owner_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), owner,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:OpenLogReplicator.pb.Schema.owner)
}

// string name = 2;
inline void Schema::clear_name() {
  name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Schema::name() const {
  // @@protoc_insertion_point(field_get:OpenLogReplicator.pb.Schema.name)
  return _internal_name();
}
inline void Schema::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:OpenLogReplicator.pb.Schema.name)
}
inline std::string* Schema::mutable_name() {
  // @@protoc_insertion_point(field_mutable:OpenLogReplicator.pb.Schema.name)
  return _internal_mutable_name();
}
inline const std::string& Schema::_internal_name() const {
  return name_.Get();
}
inline void Schema::_internal_set_name(const std::string& value) {
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Schema::set_name(std::string&& value) {
  
  name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:OpenLogReplicator.pb.Schema.name)
}
inline void Schema::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:OpenLogReplicator.pb.Schema.name)
}
inline void Schema::set_name(const char* value,
    size_t size) {
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:OpenLogReplicator.pb.Schema.name)
}
inline std::string* Schema::_internal_mutable_name() {
  
  return name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Schema::release_name() {
  // @@protoc_insertion_point(field_release:OpenLogReplicator.pb.Schema.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Schema::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:OpenLogReplicator.pb.Schema.name)
}

// uint32 obj = 3;
inline void Schema::clear_obj() {
  obj_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Schema::_internal_obj() const {
  return obj_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Schema::obj() const {
  // @@protoc_insertion_point(field_get:OpenLogReplicator.pb.Schema.obj)
  return _internal_obj();
}
inline void Schema::_internal_set_obj(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  obj_ = value;
}
inline void Schema::set_obj(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_obj(value);
  // @@protoc_insertion_point(field_set:OpenLogReplicator.pb.Schema.obj)
}

// uint64 tm = 4;
inline bool Schema::_internal_has_tm() const {
  return tm_val_case() == kTm;
}
inline void Schema::set_has_tm() {
  _oneof_case_[0] = kTm;
}
inline void Schema::clear_tm() {
  if (_internal_has_tm()) {
    tm_val_.tm_ = PROTOBUF_ULONGLONG(0);
    clear_has_tm_val();
  }
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Schema::_internal_tm() const {
  if (_internal_has_tm()) {
    return tm_val_.tm_;
  }
  return PROTOBUF_ULONGLONG(0);
}
inline void Schema::_internal_set_tm(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  if (!_internal_has_tm()) {
    clear_tm_val();
    set_has_tm();
  }
  tm_val_.tm_ = value;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Schema::tm() const {
  // @@protoc_insertion_point(field_get:OpenLogReplicator.pb.Schema.tm)
  return _internal_tm();
}
inline void Schema::set_tm(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_tm(value);
  // @@protoc_insertion_point(field_set:OpenLogReplicator.pb.Schema.tm)
}

// string tms = 5;
inline bool Schema::_internal_has_tms() const {
  return tm_val_case() == kTms;
}
inline void Schema::set_has_tms() {
  _oneof_case_[0] = kTms;
}
inline void Schema::clear_tms() {
  if (_internal_has_tms()) {
    tm_val_.tms_.Destroy(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
    clear_has_tm_val();
  }
}
inline const std::string& Schema::tms() const {
  // @@protoc_insertion_point(field_get:OpenLogReplicator.pb.Schema.tms)
  return _internal_tms();
}
inline void Schema::set_tms(const std::string& value) {
  _internal_set_tms(value);
  // @@protoc_insertion_point(field_set:OpenLogReplicator.pb.Schema.tms)
}
inline std::string* Schema::mutable_tms() {
  // @@protoc_insertion_point(field_mutable:OpenLogReplicator.pb.Schema.tms)
  return _internal_mutable_tms();
}
inline const std::string& Schema::_internal_tms() const {
  if (_internal_has_tms()) {
    return tm_val_.tms_.Get();
  }
  return *&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void Schema::_internal_set_tms(const std::string& value) {
  if (!_internal_has_tms()) {
    clear_tm_val();
    set_has_tms();
    tm_val_.tms_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  tm_val_.tms_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Schema::set_tms(std::string&& value) {
  // @@protoc_insertion_point(field_set:OpenLogReplicator.pb.Schema.tms)
  if (!_internal_has_tms()) {
    clear_tm_val();
    set_has_tms();
    tm_val_.tms_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  tm_val_.tms_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:OpenLogReplicator.pb.Schema.tms)
}
inline void Schema::set_tms(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  if (!_internal_has_tms()) {
    clear_tm_val();
    set_has_tms();
    tm_val_.tms_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  tm_val_.tms_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:OpenLogReplicator.pb.Schema.tms)
}
inline void Schema::set_tms(const char* value,
                             size_t size) {
  if (!_internal_has_tms()) {
    clear_tm_val();
    set_has_tms();
    tm_val_.tms_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  tm_val_.tms_.Set(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size),
      GetArena());
  // @@protoc_insertion_point(field_set_pointer:OpenLogReplicator.pb.Schema.tms)
}
inline std::string* Schema::_internal_mutable_tms() {
  if (!_internal_has_tms()) {
    clear_tm_val();
    set_has_tms();
    tm_val_.tms_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return tm_val_.tms_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Schema::release_tms() {
  // @@protoc_insertion_point(field_release:OpenLogReplicator.pb.Schema.tms)
  if (_internal_has_tms()) {
    clear_has_tm_val();
    return tm_val_.tms_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  } else {
    return nullptr;
  }
}
inline void Schema::set_allocated_tms(std::string* tms) {
  if (has_tm_val()) {
    clear_tm_val();
  }
  if (tms != nullptr) {
    set_has_tms();
    tm_val_.tms_.UnsafeSetDefault(tms);
    ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena();
    if (arena != nullptr) {
      arena->Own(tms);
    }
  }
  // @@protoc_insertion_point(field_set_allocated:OpenLogReplicator.pb.Schema.tms)
}

// repeated .OpenLogReplicator.pb.Column column = 6;
inline int Schema::_internal_column_size() const {
  return column_.size();
}
inline int Schema::column_size() const {
  return _internal_column_size();
}
inline void Schema::clear_column() {
  column_.Clear();
}
inline ::OpenLogReplicator::pb::Column* Schema::mutable_column(int index) {
  // @@protoc_insertion_point(field_mutable:OpenLogReplicator.pb.Schema.column)
  return column_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::OpenLogReplicator::pb::Column >*
Schema::mutable_column() {
  // @@protoc_insertion_point(field_mutable_list:OpenLogReplicator.pb.Schema.column)
  return &column_;
}
inline const ::OpenLogReplicator::pb::Column& Schema::_internal_column(int index) const {
  return column_.Get(index);
}
inline const ::OpenLogReplicator::pb::Column& Schema::column(int index) const {
  // @@protoc_insertion_point(field_get:OpenLogReplicator.pb.Schema.column)
  return _internal_column(index);
}
inline ::OpenLogReplicator::pb::Column* Schema::_internal_add_column() {
  return column_.Add();
}
inline ::OpenLogReplicator::pb::Column* Schema::add_column() {
  // @@protoc_insertion_point(field_add:OpenLogReplicator.pb.Schema.column)
  return _internal_add_column();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::OpenLogReplicator::pb::Column >&
Schema::column() const {
  // @@protoc_insertion_point(field_list:OpenLogReplicator.pb.Schema.column)
  return column_;
}

inline bool Schema::has_tm_val() const {
  return tm_val_case() != TM_VAL_NOT_SET;
}
inline void Schema::clear_has_tm_val() {
  _oneof_case_[0] = TM_VAL_NOT_SET;
}
inline Schema::TmValCase Schema::tm_val_case() const {
  return Schema::TmValCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Payload

// .OpenLogReplicator.pb.Op op = 1;
inline void Payload::clear_op() {
  op_ = 0;
}
inline ::OpenLogReplicator::pb::Op Payload::_internal_op() const {
  return static_cast< ::OpenLogReplicator::pb::Op >(op_);
}
inline ::OpenLogReplicator::pb::Op Payload::op() const {
  // @@protoc_insertion_point(field_get:OpenLogReplicator.pb.Payload.op)
  return _internal_op();
}
inline void Payload::_internal_set_op(::OpenLogReplicator::pb::Op value) {
  
  op_ = value;
}
inline void Payload::set_op(::OpenLogReplicator::pb::Op value) {
  _internal_set_op(value);
  // @@protoc_insertion_point(field_set:OpenLogReplicator.pb.Payload.op)
}

// .OpenLogReplicator.pb.Schema schema = 2;
inline bool Payload::_internal_has_schema() const {
  return this != internal_default_instance() && schema_ != nullptr;
}
inline bool Payload::has_schema() const {
  return _internal_has_schema();
}
inline void Payload::clear_schema() {
  if (GetArena() == nullptr && schema_ != nullptr) {
    delete schema_;
  }
  schema_ = nullptr;
}
inline const ::OpenLogReplicator::pb::Schema& Payload::_internal_schema() const {
  const ::OpenLogReplicator::pb::Schema* p = schema_;
  return p != nullptr ? *p : *reinterpret_cast<const ::OpenLogReplicator::pb::Schema*>(
      &::OpenLogReplicator::pb::_Schema_default_instance_);
}
inline const ::OpenLogReplicator::pb::Schema& Payload::schema() const {
  // @@protoc_insertion_point(field_get:OpenLogReplicator.pb.Payload.schema)
  return _internal_schema();
}
inline void Payload::unsafe_arena_set_allocated_schema(
    ::OpenLogReplicator::pb::Schema* schema) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(schema_);
  }
  schema_ = schema;
  if (schema) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:OpenLogReplicator.pb.Payload.schema)
}
inline ::OpenLogReplicator::pb::Schema* Payload::release_schema() {
  
  ::OpenLogReplicator::pb::Schema* temp = schema_;
  schema_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::OpenLogReplicator::pb::Schema* Payload::unsafe_arena_release_schema() {
  // @@protoc_insertion_point(field_release:OpenLogReplicator.pb.Payload.schema)
  
  ::OpenLogReplicator::pb::Schema* temp = schema_;
  schema_ = nullptr;
  return temp;
}
inline ::OpenLogReplicator::pb::Schema* Payload::_internal_mutable_schema() {
  
  if (schema_ == nullptr) {
    auto* p = CreateMaybeMessage<::OpenLogReplicator::pb::Schema>(GetArena());
    schema_ = p;
  }
  return schema_;
}
inline ::OpenLogReplicator::pb::Schema* Payload::mutable_schema() {
  // @@protoc_insertion_point(field_mutable:OpenLogReplicator.pb.Payload.schema)
  return _internal_mutable_schema();
}
inline void Payload::set_allocated_schema(::OpenLogReplicator::pb::Schema* schema) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete schema_;
  }
  if (schema) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(schema);
    if (message_arena != submessage_arena) {
      schema = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, schema, submessage_arena);
    }
    
  } else {
    
  }
  schema_ = schema;
  // @@protoc_insertion_point(field_set_allocated:OpenLogReplicator.pb.Payload.schema)
}

// string rid = 3;
inline void Payload::clear_rid() {
  rid_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Payload::rid() const {
  // @@protoc_insertion_point(field_get:OpenLogReplicator.pb.Payload.rid)
  return _internal_rid();
}
inline void Payload::set_rid(const std::string& value) {
  _internal_set_rid(value);
  // @@protoc_insertion_point(field_set:OpenLogReplicator.pb.Payload.rid)
}
inline std::string* Payload::mutable_rid() {
  // @@protoc_insertion_point(field_mutable:OpenLogReplicator.pb.Payload.rid)
  return _internal_mutable_rid();
}
inline const std::string& Payload::_internal_rid() const {
  return rid_.Get();
}
inline void Payload::_internal_set_rid(const std::string& value) {
  
  rid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Payload::set_rid(std::string&& value) {
  
  rid_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:OpenLogReplicator.pb.Payload.rid)
}
inline void Payload::set_rid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  rid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:OpenLogReplicator.pb.Payload.rid)
}
inline void Payload::set_rid(const char* value,
    size_t size) {
  
  rid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:OpenLogReplicator.pb.Payload.rid)
}
inline std::string* Payload::_internal_mutable_rid() {
  
  return rid_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Payload::release_rid() {
  // @@protoc_insertion_point(field_release:OpenLogReplicator.pb.Payload.rid)
  return rid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Payload::set_allocated_rid(std::string* rid) {
  if (rid != nullptr) {
    
  } else {
    
  }
  rid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), rid,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:OpenLogReplicator.pb.Payload.rid)
}

// repeated .OpenLogReplicator.pb.Value before = 4;
inline int Payload::_internal_before_size() const {
  return before_.size();
}
inline int Payload::before_size() const {
  return _internal_before_size();
}
inline void Payload::clear_before() {
  before_.Clear();
}
inline ::OpenLogReplicator::pb::Value* Payload::mutable_before(int index) {
  // @@protoc_insertion_point(field_mutable:OpenLogReplicator.pb.Payload.before)
  return before_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::OpenLogReplicator::pb::Value >*
Payload::mutable_before() {
  // @@protoc_insertion_point(field_mutable_list:OpenLogReplicator.pb.Payload.before)
  return &before_;
}
inline const ::OpenLogReplicator::pb::Value& Payload::_internal_before(int index) const {
  return before_.Get(index);
}
inline const ::OpenLogReplicator::pb::Value& Payload::before(int index) const {
  // @@protoc_insertion_point(field_get:OpenLogReplicator.pb.Payload.before)
  return _internal_before(index);
}
inline ::OpenLogReplicator::pb::Value* Payload::_internal_add_before() {
  return before_.Add();
}
inline ::OpenLogReplicator::pb::Value* Payload::add_before() {
  // @@protoc_insertion_point(field_add:OpenLogReplicator.pb.Payload.before)
  return _internal_add_before();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::OpenLogReplicator::pb::Value >&
Payload::before() const {
  // @@protoc_insertion_point(field_list:OpenLogReplicator.pb.Payload.before)
  return before_;
}

// repeated .OpenLogReplicator.pb.Value after = 5;
inline int Payload::_internal_after_size() const {
  return after_.size();
}
inline int Payload::after_size() const {
  return _internal_after_size();
}
inline void Payload::clear_after() {
  after_.Clear();
}
inline ::OpenLogReplicator::pb::Value* Payload::mutable_after(int index) {
  // @@protoc_insertion_point(field_mutable:OpenLogReplicator.pb.Payload.after)
  return after_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::OpenLogReplicator::pb::Value >*
Payload::mutable_after() {
  // @@protoc_insertion_point(field_mutable_list:OpenLogReplicator.pb.Payload.after)
  return &after_;
}
inline const ::OpenLogReplicator::pb::Value& Payload::_internal_after(int index) const {
  return after_.Get(index);
}
inline const ::OpenLogReplicator::pb::Value& Payload::after(int index) const {
  // @@protoc_insertion_point(field_get:OpenLogReplicator.pb.Payload.after)
  return _internal_after(index);
}
inline ::OpenLogReplicator::pb::Value* Payload::_internal_add_after() {
  return after_.Add();
}
inline ::OpenLogReplicator::pb::Value* Payload::add_after() {
  // @@protoc_insertion_point(field_add:OpenLogReplicator.pb.Payload.after)
  return _internal_add_after();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::OpenLogReplicator::pb::Value >&
Payload::after() const {
  // @@protoc_insertion_point(field_list:OpenLogReplicator.pb.Payload.after)
  return after_;
}

// string ddl = 6;
inline void Payload::clear_ddl() {
  ddl_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Payload::ddl() const {
  // @@protoc_insertion_point(field_get:OpenLogReplicator.pb.Payload.ddl)
  return _internal_ddl();
}
inline void Payload::set_ddl(const std::string& value) {
  _internal_set_ddl(value);
  // @@protoc_insertion_point(field_set:OpenLogReplicator.pb.Payload.ddl)
}
inline std::string* Payload::mutable_ddl() {
  // @@protoc_insertion_point(field_mutable:OpenLogReplicator.pb.Payload.ddl)
  return _internal_mutable_ddl();
}
inline const std::string& Payload::_internal_ddl() const {
  return ddl_.Get();
}
inline void Payload::_internal_set_ddl(const std::string& value) {
  
  ddl_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Payload::set_ddl(std::string&& value) {
  
  ddl_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:OpenLogReplicator.pb.Payload.ddl)
}
inline void Payload::set_ddl(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  ddl_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:OpenLogReplicator.pb.Payload.ddl)
}
inline void Payload::set_ddl(const char* value,
    size_t size) {
  
  ddl_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:OpenLogReplicator.pb.Payload.ddl)
}
inline std::string* Payload::_internal_mutable_ddl() {
  
  return ddl_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Payload::release_ddl() {
  // @@protoc_insertion_point(field_release:OpenLogReplicator.pb.Payload.ddl)
  return ddl_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Payload::set_allocated_ddl(std::string* ddl) {
  if (ddl != nullptr) {
    
  } else {
    
  }
  ddl_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ddl,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:OpenLogReplicator.pb.Payload.ddl)
}

// -------------------------------------------------------------------

// SchemaRequest

// string mask = 1;
inline void SchemaRequest::clear_mask() {
  mask_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& SchemaRequest::mask() const {
  // @@protoc_insertion_point(field_get:OpenLogReplicator.pb.SchemaRequest.mask)
  return _internal_mask();
}
inline void SchemaRequest::set_mask(const std::string& value) {
  _internal_set_mask(value);
  // @@protoc_insertion_point(field_set:OpenLogReplicator.pb.SchemaRequest.mask)
}
inline std::string* SchemaRequest::mutable_mask() {
  // @@protoc_insertion_point(field_mutable:OpenLogReplicator.pb.SchemaRequest.mask)
  return _internal_mutable_mask();
}
inline const std::string& SchemaRequest::_internal_mask() const {
  return mask_.Get();
}
inline void SchemaRequest::_internal_set_mask(const std::string& value) {
  
  mask_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void SchemaRequest::set_mask(std::string&& value) {
  
  mask_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:OpenLogReplicator.pb.SchemaRequest.mask)
}
inline void SchemaRequest::set_mask(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  mask_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:OpenLogReplicator.pb.SchemaRequest.mask)
}
inline void SchemaRequest::set_mask(const char* value,
    size_t size) {
  
  mask_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:OpenLogReplicator.pb.SchemaRequest.mask)
}
inline std::string* SchemaRequest::_internal_mutable_mask() {
  
  return mask_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* SchemaRequest::release_mask() {
  // @@protoc_insertion_point(field_release:OpenLogReplicator.pb.SchemaRequest.mask)
  return mask_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void SchemaRequest::set_allocated_mask(std::string* mask) {
  if (mask != nullptr) {
    
  } else {
    
  }
  mask_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), mask,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:OpenLogReplicator.pb.SchemaRequest.mask)
}

// string filter = 2;
inline void SchemaRequest::clear_filter() {
  filter_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& SchemaRequest::filter() const {
  // @@protoc_insertion_point(field_get:OpenLogReplicator.pb.SchemaRequest.filter)
  return _internal_filter();
}
inline void SchemaRequest::set_filter(const std::string& value) {
  _internal_set_filter(value);
  // @@protoc_insertion_point(field_set:OpenLogReplicator.pb.SchemaRequest.filter)
}
inline std::string* SchemaRequest::mutable_filter() {
  // @@protoc_insertion_point(field_mutable:OpenLogReplicator.pb.SchemaRequest.filter)
  return _internal_mutable_filter();
}
inline const std::string& SchemaRequest::_internal_filter() const {
  return filter_.Get();
}
inline void SchemaRequest::_internal_set_filter(const std::string& value) {
  
  filter_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void SchemaRequest::set_filter(std::string&& value) {
  
  filter_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:OpenLogReplicator.pb.SchemaRequest.filter)
}
inline void SchemaRequest::set_filter(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  filter_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:OpenLogReplicator.pb.SchemaRequest.filter)
}
inline void SchemaRequest::set_filter(const char* value,
    size_t size) {
  
  filter_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:OpenLogReplicator.pb.SchemaRequest.filter)
}
inline std::string* SchemaRequest::_internal_mutable_filter() {
  
  return filter_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* SchemaRequest::release_filter() {
  // @@protoc_insertion_point(field_release:OpenLogReplicator.pb.SchemaRequest.filter)
  return filter_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void SchemaRequest::set_allocated_filter(std::string* filter) {
  if (filter != nullptr) {
    
  } else {
    
  }
  filter_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), filter,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:OpenLogReplicator.pb.SchemaRequest.filter)
}

// -------------------------------------------------------------------

// RedoRequest

// .OpenLogReplicator.pb.RequestCode code = 1;
inline void RedoRequest::clear_code() {
  code_ = 0;
}
inline ::OpenLogReplicator::pb::RequestCode RedoRequest::_internal_code() const {
  return static_cast< ::OpenLogReplicator::pb::RequestCode >(code_);
}
inline ::OpenLogReplicator::pb::RequestCode RedoRequest::code() const {
  // @@protoc_insertion_point(field_get:OpenLogReplicator.pb.RedoRequest.code)
  return _internal_code();
}
inline void RedoRequest::_internal_set_code(::OpenLogReplicator::pb::RequestCode value) {
  
  code_ = value;
}
inline void RedoRequest::set_code(::OpenLogReplicator::pb::RequestCode value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:OpenLogReplicator.pb.RedoRequest.code)
}

// string database_name = 2;
inline void RedoRequest::clear_database_name() {
  database_name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& RedoRequest::database_name() const {
  // @@protoc_insertion_point(field_get:OpenLogReplicator.pb.RedoRequest.database_name)
  return _internal_database_name();
}
inline void RedoRequest::set_database_name(const std::string& value) {
  _internal_set_database_name(value);
  // @@protoc_insertion_point(field_set:OpenLogReplicator.pb.RedoRequest.database_name)
}
inline std::string* RedoRequest::mutable_database_name() {
  // @@protoc_insertion_point(field_mutable:OpenLogReplicator.pb.RedoRequest.database_name)
  return _internal_mutable_database_name();
}
inline const std::string& RedoRequest::_internal_database_name() const {
  return database_name_.Get();
}
inline void RedoRequest::_internal_set_database_name(const std::string& value) {
  
  database_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void RedoRequest::set_database_name(std::string&& value) {
  
  database_name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:OpenLogReplicator.pb.RedoRequest.database_name)
}
inline void RedoRequest::set_database_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  database_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:OpenLogReplicator.pb.RedoRequest.database_name)
}
inline void RedoRequest::set_database_name(const char* value,
    size_t size) {
  
  database_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:OpenLogReplicator.pb.RedoRequest.database_name)
}
inline std::string* RedoRequest::_internal_mutable_database_name() {
  
  return database_name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* RedoRequest::release_database_name() {
  // @@protoc_insertion_point(field_release:OpenLogReplicator.pb.RedoRequest.database_name)
  return database_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void RedoRequest::set_allocated_database_name(std::string* database_name) {
  if (database_name != nullptr) {
    
  } else {
    
  }
  database_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), database_name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:OpenLogReplicator.pb.RedoRequest.database_name)
}

// uint64 scn = 3;
inline bool RedoRequest::_internal_has_scn() const {
  return tm_val_case() == kScn;
}
inline void RedoRequest::set_has_scn() {
  _oneof_case_[0] = kScn;
}
inline void RedoRequest::clear_scn() {
  if (_internal_has_scn()) {
    tm_val_.scn_ = PROTOBUF_ULONGLONG(0);
    clear_has_tm_val();
  }
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 RedoRequest::_internal_scn() const {
  if (_internal_has_scn()) {
    return tm_val_.scn_;
  }
  return PROTOBUF_ULONGLONG(0);
}
inline void RedoRequest::_internal_set_scn(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  if (!_internal_has_scn()) {
    clear_tm_val();
    set_has_scn();
  }
  tm_val_.scn_ = value;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 RedoRequest::scn() const {
  // @@protoc_insertion_point(field_get:OpenLogReplicator.pb.RedoRequest.scn)
  return _internal_scn();
}
inline void RedoRequest::set_scn(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_scn(value);
  // @@protoc_insertion_point(field_set:OpenLogReplicator.pb.RedoRequest.scn)
}

// uint64 seq = 4;
inline bool RedoRequest::_internal_has_seq() const {
  return tm_val_case() == kSeq;
}
inline void RedoRequest::set_has_seq() {
  _oneof_case_[0] = kSeq;
}
inline void RedoRequest::clear_seq() {
  if (_internal_has_seq()) {
    tm_val_.seq_ = PROTOBUF_ULONGLONG(0);
    clear_has_tm_val();
  }
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 RedoRequest::_internal_seq() const {
  if (_internal_has_seq()) {
    return tm_val_.seq_;
  }
  return PROTOBUF_ULONGLONG(0);
}
inline void RedoRequest::_internal_set_seq(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  if (!_internal_has_seq()) {
    clear_tm_val();
    set_has_seq();
  }
  tm_val_.seq_ = value;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 RedoRequest::seq() const {
  // @@protoc_insertion_point(field_get:OpenLogReplicator.pb.RedoRequest.seq)
  return _internal_seq();
}
inline void RedoRequest::set_seq(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_seq(value);
  // @@protoc_insertion_point(field_set:OpenLogReplicator.pb.RedoRequest.seq)
}

// string tms = 5;
inline bool RedoRequest::_internal_has_tms() const {
  return tm_val_case() == kTms;
}
inline void RedoRequest::set_has_tms() {
  _oneof_case_[0] = kTms;
}
inline void RedoRequest::clear_tms() {
  if (_internal_has_tms()) {
    tm_val_.tms_.Destroy(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
    clear_has_tm_val();
  }
}
inline const std::string& RedoRequest::tms() const {
  // @@protoc_insertion_point(field_get:OpenLogReplicator.pb.RedoRequest.tms)
  return _internal_tms();
}
inline void RedoRequest::set_tms(const std::string& value) {
  _internal_set_tms(value);
  // @@protoc_insertion_point(field_set:OpenLogReplicator.pb.RedoRequest.tms)
}
inline std::string* RedoRequest::mutable_tms() {
  // @@protoc_insertion_point(field_mutable:OpenLogReplicator.pb.RedoRequest.tms)
  return _internal_mutable_tms();
}
inline const std::string& RedoRequest::_internal_tms() const {
  if (_internal_has_tms()) {
    return tm_val_.tms_.Get();
  }
  return *&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void RedoRequest::_internal_set_tms(const std::string& value) {
  if (!_internal_has_tms()) {
    clear_tm_val();
    set_has_tms();
    tm_val_.tms_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  tm_val_.tms_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void RedoRequest::set_tms(std::string&& value) {
  // @@protoc_insertion_point(field_set:OpenLogReplicator.pb.RedoRequest.tms)
  if (!_internal_has_tms()) {
    clear_tm_val();
    set_has_tms();
    tm_val_.tms_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  tm_val_.tms_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:OpenLogReplicator.pb.RedoRequest.tms)
}
inline void RedoRequest::set_tms(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  if (!_internal_has_tms()) {
    clear_tm_val();
    set_has_tms();
    tm_val_.tms_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  tm_val_.tms_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:OpenLogReplicator.pb.RedoRequest.tms)
}
inline void RedoRequest::set_tms(const char* value,
                             size_t size) {
  if (!_internal_has_tms()) {
    clear_tm_val();
    set_has_tms();
    tm_val_.tms_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  tm_val_.tms_.Set(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size),
      GetArena());
  // @@protoc_insertion_point(field_set_pointer:OpenLogReplicator.pb.RedoRequest.tms)
}
inline std::string* RedoRequest::_internal_mutable_tms() {
  if (!_internal_has_tms()) {
    clear_tm_val();
    set_has_tms();
    tm_val_.tms_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return tm_val_.tms_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* RedoRequest::release_tms() {
  // @@protoc_insertion_point(field_release:OpenLogReplicator.pb.RedoRequest.tms)
  if (_internal_has_tms()) {
    clear_has_tm_val();
    return tm_val_.tms_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  } else {
    return nullptr;
  }
}
inline void RedoRequest::set_allocated_tms(std::string* tms) {
  if (has_tm_val()) {
    clear_tm_val();
  }
  if (tms != nullptr) {
    set_has_tms();
    tm_val_.tms_.UnsafeSetDefault(tms);
    ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena();
    if (arena != nullptr) {
      arena->Own(tms);
    }
  }
  // @@protoc_insertion_point(field_set_allocated:OpenLogReplicator.pb.RedoRequest.tms)
}

// int64 tm_rel = 6;
inline bool RedoRequest::_internal_has_tm_rel() const {
  return tm_val_case() == kTmRel;
}
inline void RedoRequest::set_has_tm_rel() {
  _oneof_case_[0] = kTmRel;
}
inline void RedoRequest::clear_tm_rel() {
  if (_internal_has_tm_rel()) {
    tm_val_.tm_rel_ = PROTOBUF_LONGLONG(0);
    clear_has_tm_val();
  }
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RedoRequest::_internal_tm_rel() const {
  if (_internal_has_tm_rel()) {
    return tm_val_.tm_rel_;
  }
  return PROTOBUF_LONGLONG(0);
}
inline void RedoRequest::_internal_set_tm_rel(::PROTOBUF_NAMESPACE_ID::int64 value) {
  if (!_internal_has_tm_rel()) {
    clear_tm_val();
    set_has_tm_rel();
  }
  tm_val_.tm_rel_ = value;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RedoRequest::tm_rel() const {
  // @@protoc_insertion_point(field_get:OpenLogReplicator.pb.RedoRequest.tm_rel)
  return _internal_tm_rel();
}
inline void RedoRequest::set_tm_rel(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_tm_rel(value);
  // @@protoc_insertion_point(field_set:OpenLogReplicator.pb.RedoRequest.tm_rel)
}

// repeated .OpenLogReplicator.pb.SchemaRequest schema = 7;
inline int RedoRequest::_internal_schema_size() const {
  return schema_.size();
}
inline int RedoRequest::schema_size() const {
  return _internal_schema_size();
}
inline void RedoRequest::clear_schema() {
  schema_.Clear();
}
inline ::OpenLogReplicator::pb::SchemaRequest* RedoRequest::mutable_schema(int index) {
  // @@protoc_insertion_point(field_mutable:OpenLogReplicator.pb.RedoRequest.schema)
  return schema_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::OpenLogReplicator::pb::SchemaRequest >*
RedoRequest::mutable_schema() {
  // @@protoc_insertion_point(field_mutable_list:OpenLogReplicator.pb.RedoRequest.schema)
  return &schema_;
}
inline const ::OpenLogReplicator::pb::SchemaRequest& RedoRequest::_internal_schema(int index) const {
  return schema_.Get(index);
}
inline const ::OpenLogReplicator::pb::SchemaRequest& RedoRequest::schema(int index) const {
  // @@protoc_insertion_point(field_get:OpenLogReplicator.pb.RedoRequest.schema)
  return _internal_schema(index);
}
inline ::OpenLogReplicator::pb::SchemaRequest* RedoRequest::_internal_add_schema() {
  return schema_.Add();
}
inline ::OpenLogReplicator::pb::SchemaRequest* RedoRequest::add_schema() {
  // @@protoc_insertion_point(field_add:OpenLogReplicator.pb.RedoRequest.schema)
  return _internal_add_schema();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::OpenLogReplicator::pb::SchemaRequest >&
RedoRequest::schema() const {
  // @@protoc_insertion_point(field_list:OpenLogReplicator.pb.RedoRequest.schema)
  return schema_;
}

inline bool RedoRequest::has_tm_val() const {
  return tm_val_case() != TM_VAL_NOT_SET;
}
inline void RedoRequest::clear_has_tm_val() {
  _oneof_case_[0] = TM_VAL_NOT_SET;
}
inline RedoRequest::TmValCase RedoRequest::tm_val_case() const {
  return RedoRequest::TmValCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// RedoResponse

// .OpenLogReplicator.pb.ResponseCode code = 1;
inline void RedoResponse::clear_code() {
  code_ = 0;
}
inline ::OpenLogReplicator::pb::ResponseCode RedoResponse::_internal_code() const {
  return static_cast< ::OpenLogReplicator::pb::ResponseCode >(code_);
}
inline ::OpenLogReplicator::pb::ResponseCode RedoResponse::code() const {
  // @@protoc_insertion_point(field_get:OpenLogReplicator.pb.RedoResponse.code)
  return _internal_code();
}
inline void RedoResponse::_internal_set_code(::OpenLogReplicator::pb::ResponseCode value) {
  
  code_ = value;
}
inline void RedoResponse::set_code(::OpenLogReplicator::pb::ResponseCode value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:OpenLogReplicator.pb.RedoResponse.code)
}

// uint64 scn = 2;
inline bool RedoResponse::_internal_has_scn() const {
  return scn_val_case() == kScn;
}
inline void RedoResponse::set_has_scn() {
  _oneof_case_[0] = kScn;
}
inline void RedoResponse::clear_scn() {
  if (_internal_has_scn()) {
    scn_val_.scn_ = PROTOBUF_ULONGLONG(0);
    clear_has_scn_val();
  }
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 RedoResponse::_internal_scn() const {
  if (_internal_has_scn()) {
    return scn_val_.scn_;
  }
  return PROTOBUF_ULONGLONG(0);
}
inline void RedoResponse::_internal_set_scn(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  if (!_internal_has_scn()) {
    clear_scn_val();
    set_has_scn();
  }
  scn_val_.scn_ = value;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 RedoResponse::scn() const {
  // @@protoc_insertion_point(field_get:OpenLogReplicator.pb.RedoResponse.scn)
  return _internal_scn();
}
inline void RedoResponse::set_scn(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_scn(value);
  // @@protoc_insertion_point(field_set:OpenLogReplicator.pb.RedoResponse.scn)
}

// string scns = 3;
inline bool RedoResponse::_internal_has_scns() const {
  return scn_val_case() == kScns;
}
inline void RedoResponse::set_has_scns() {
  _oneof_case_[0] = kScns;
}
inline void RedoResponse::clear_scns() {
  if (_internal_has_scns()) {
    scn_val_.scns_.Destroy(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
    clear_has_scn_val();
  }
}
inline const std::string& RedoResponse::scns() const {
  // @@protoc_insertion_point(field_get:OpenLogReplicator.pb.RedoResponse.scns)
  return _internal_scns();
}
inline void RedoResponse::set_scns(const std::string& value) {
  _internal_set_scns(value);
  // @@protoc_insertion_point(field_set:OpenLogReplicator.pb.RedoResponse.scns)
}
inline std::string* RedoResponse::mutable_scns() {
  // @@protoc_insertion_point(field_mutable:OpenLogReplicator.pb.RedoResponse.scns)
  return _internal_mutable_scns();
}
inline const std::string& RedoResponse::_internal_scns() const {
  if (_internal_has_scns()) {
    return scn_val_.scns_.Get();
  }
  return *&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void RedoResponse::_internal_set_scns(const std::string& value) {
  if (!_internal_has_scns()) {
    clear_scn_val();
    set_has_scns();
    scn_val_.scns_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  scn_val_.scns_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void RedoResponse::set_scns(std::string&& value) {
  // @@protoc_insertion_point(field_set:OpenLogReplicator.pb.RedoResponse.scns)
  if (!_internal_has_scns()) {
    clear_scn_val();
    set_has_scns();
    scn_val_.scns_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  scn_val_.scns_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:OpenLogReplicator.pb.RedoResponse.scns)
}
inline void RedoResponse::set_scns(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  if (!_internal_has_scns()) {
    clear_scn_val();
    set_has_scns();
    scn_val_.scns_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  scn_val_.scns_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:OpenLogReplicator.pb.RedoResponse.scns)
}
inline void RedoResponse::set_scns(const char* value,
                             size_t size) {
  if (!_internal_has_scns()) {
    clear_scn_val();
    set_has_scns();
    scn_val_.scns_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  scn_val_.scns_.Set(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size),
      GetArena());
  // @@protoc_insertion_point(field_set_pointer:OpenLogReplicator.pb.RedoResponse.scns)
}
inline std::string* RedoResponse::_internal_mutable_scns() {
  if (!_internal_has_scns()) {
    clear_scn_val();
    set_has_scns();
    scn_val_.scns_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return scn_val_.scns_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* RedoResponse::release_scns() {
  // @@protoc_insertion_point(field_release:OpenLogReplicator.pb.RedoResponse.scns)
  if (_internal_has_scns()) {
    clear_has_scn_val();
    return scn_val_.scns_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  } else {
    return nullptr;
  }
}
inline void RedoResponse::set_allocated_scns(std::string* scns) {
  if (has_scn_val()) {
    clear_scn_val();
  }
  if (scns != nullptr) {
    set_has_scns();
    scn_val_.scns_.UnsafeSetDefault(scns);
    ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena();
    if (arena != nullptr) {
      arena->Own(scns);
    }
  }
  // @@protoc_insertion_point(field_set_allocated:OpenLogReplicator.pb.RedoResponse.scns)
}

// uint64 tm = 4;
inline bool RedoResponse::_internal_has_tm() const {
  return tm_val_case() == kTm;
}
inline void RedoResponse::set_has_tm() {
  _oneof_case_[1] = kTm;
}
inline void RedoResponse::clear_tm() {
  if (_internal_has_tm()) {
    tm_val_.tm_ = PROTOBUF_ULONGLONG(0);
    clear_has_tm_val();
  }
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 RedoResponse::_internal_tm() const {
  if (_internal_has_tm()) {
    return tm_val_.tm_;
  }
  return PROTOBUF_ULONGLONG(0);
}
inline void RedoResponse::_internal_set_tm(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  if (!_internal_has_tm()) {
    clear_tm_val();
    set_has_tm();
  }
  tm_val_.tm_ = value;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 RedoResponse::tm() const {
  // @@protoc_insertion_point(field_get:OpenLogReplicator.pb.RedoResponse.tm)
  return _internal_tm();
}
inline void RedoResponse::set_tm(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_tm(value);
  // @@protoc_insertion_point(field_set:OpenLogReplicator.pb.RedoResponse.tm)
}

// string tms = 5;
inline bool RedoResponse::_internal_has_tms() const {
  return tm_val_case() == kTms;
}
inline void RedoResponse::set_has_tms() {
  _oneof_case_[1] = kTms;
}
inline void RedoResponse::clear_tms() {
  if (_internal_has_tms()) {
    tm_val_.tms_.Destroy(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
    clear_has_tm_val();
  }
}
inline const std::string& RedoResponse::tms() const {
  // @@protoc_insertion_point(field_get:OpenLogReplicator.pb.RedoResponse.tms)
  return _internal_tms();
}
inline void RedoResponse::set_tms(const std::string& value) {
  _internal_set_tms(value);
  // @@protoc_insertion_point(field_set:OpenLogReplicator.pb.RedoResponse.tms)
}
inline std::string* RedoResponse::mutable_tms() {
  // @@protoc_insertion_point(field_mutable:OpenLogReplicator.pb.RedoResponse.tms)
  return _internal_mutable_tms();
}
inline const std::string& RedoResponse::_internal_tms() const {
  if (_internal_has_tms()) {
    return tm_val_.tms_.Get();
  }
  return *&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void RedoResponse::_internal_set_tms(const std::string& value) {
  if (!_internal_has_tms()) {
    clear_tm_val();
    set_has_tms();
    tm_val_.tms_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  tm_val_.tms_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void RedoResponse::set_tms(std::string&& value) {
  // @@protoc_insertion_point(field_set:OpenLogReplicator.pb.RedoResponse.tms)
  if (!_internal_has_tms()) {
    clear_tm_val();
    set_has_tms();
    tm_val_.tms_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  tm_val_.tms_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:OpenLogReplicator.pb.RedoResponse.tms)
}
inline void RedoResponse::set_tms(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  if (!_internal_has_tms()) {
    clear_tm_val();
    set_has_tms();
    tm_val_.tms_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  tm_val_.tms_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:OpenLogReplicator.pb.RedoResponse.tms)
}
inline void RedoResponse::set_tms(const char* value,
                             size_t size) {
  if (!_internal_has_tms()) {
    clear_tm_val();
    set_has_tms();
    tm_val_.tms_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  tm_val_.tms_.Set(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size),
      GetArena());
  // @@protoc_insertion_point(field_set_pointer:OpenLogReplicator.pb.RedoResponse.tms)
}
inline std::string* RedoResponse::_internal_mutable_tms() {
  if (!_internal_has_tms()) {
    clear_tm_val();
    set_has_tms();
    tm_val_.tms_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return tm_val_.tms_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* RedoResponse::release_tms() {
  // @@protoc_insertion_point(field_release:OpenLogReplicator.pb.RedoResponse.tms)
  if (_internal_has_tms()) {
    clear_has_tm_val();
    return tm_val_.tms_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  } else {
    return nullptr;
  }
}
inline void RedoResponse::set_allocated_tms(std::string* tms) {
  if (has_tm_val()) {
    clear_tm_val();
  }
  if (tms != nullptr) {
    set_has_tms();
    tm_val_.tms_.UnsafeSetDefault(tms);
    ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena();
    if (arena != nullptr) {
      arena->Own(tms);
    }
  }
  // @@protoc_insertion_point(field_set_allocated:OpenLogReplicator.pb.RedoResponse.tms)
}

// string xid = 6;
inline bool RedoResponse::_internal_has_xid() const {
  return xid_val_case() == kXid;
}
inline void RedoResponse::set_has_xid() {
  _oneof_case_[2] = kXid;
}
inline void RedoResponse::clear_xid() {
  if (_internal_has_xid()) {
    xid_val_.xid_.Destroy(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
    clear_has_xid_val();
  }
}
inline const std::string& RedoResponse::xid() const {
  // @@protoc_insertion_point(field_get:OpenLogReplicator.pb.RedoResponse.xid)
  return _internal_xid();
}
inline void RedoResponse::set_xid(const std::string& value) {
  _internal_set_xid(value);
  // @@protoc_insertion_point(field_set:OpenLogReplicator.pb.RedoResponse.xid)
}
inline std::string* RedoResponse::mutable_xid() {
  // @@protoc_insertion_point(field_mutable:OpenLogReplicator.pb.RedoResponse.xid)
  return _internal_mutable_xid();
}
inline const std::string& RedoResponse::_internal_xid() const {
  if (_internal_has_xid()) {
    return xid_val_.xid_.Get();
  }
  return *&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void RedoResponse::_internal_set_xid(const std::string& value) {
  if (!_internal_has_xid()) {
    clear_xid_val();
    set_has_xid();
    xid_val_.xid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  xid_val_.xid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void RedoResponse::set_xid(std::string&& value) {
  // @@protoc_insertion_point(field_set:OpenLogReplicator.pb.RedoResponse.xid)
  if (!_internal_has_xid()) {
    clear_xid_val();
    set_has_xid();
    xid_val_.xid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  xid_val_.xid_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:OpenLogReplicator.pb.RedoResponse.xid)
}
inline void RedoResponse::set_xid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  if (!_internal_has_xid()) {
    clear_xid_val();
    set_has_xid();
    xid_val_.xid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  xid_val_.xid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:OpenLogReplicator.pb.RedoResponse.xid)
}
inline void RedoResponse::set_xid(const char* value,
                             size_t size) {
  if (!_internal_has_xid()) {
    clear_xid_val();
    set_has_xid();
    xid_val_.xid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  xid_val_.xid_.Set(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size),
      GetArena());
  // @@protoc_insertion_point(field_set_pointer:OpenLogReplicator.pb.RedoResponse.xid)
}
inline std::string* RedoResponse::_internal_mutable_xid() {
  if (!_internal_has_xid()) {
    clear_xid_val();
    set_has_xid();
    xid_val_.xid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return xid_val_.xid_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* RedoResponse::release_xid() {
  // @@protoc_insertion_point(field_release:OpenLogReplicator.pb.RedoResponse.xid)
  if (_internal_has_xid()) {
    clear_has_xid_val();
    return xid_val_.xid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  } else {
    return nullptr;
  }
}
inline void RedoResponse::set_allocated_xid(std::string* xid) {
  if (has_xid_val()) {
    clear_xid_val();
  }
  if (xid != nullptr) {
    set_has_xid();
    xid_val_.xid_.UnsafeSetDefault(xid);
    ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena();
    if (arena != nullptr) {
      arena->Own(xid);
    }
  }
  // @@protoc_insertion_point(field_set_allocated:OpenLogReplicator.pb.RedoResponse.xid)
}

// uint64 xidn = 7;
inline bool RedoResponse::_internal_has_xidn() const {
  return xid_val_case() == kXidn;
}
inline void RedoResponse::set_has_xidn() {
  _oneof_case_[2] = kXidn;
}
inline void RedoResponse::clear_xidn() {
  if (_internal_has_xidn()) {
    xid_val_.xidn_ = PROTOBUF_ULONGLONG(0);
    clear_has_xid_val();
  }
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 RedoResponse::_internal_xidn() const {
  if (_internal_has_xidn()) {
    return xid_val_.xidn_;
  }
  return PROTOBUF_ULONGLONG(0);
}
inline void RedoResponse::_internal_set_xidn(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  if (!_internal_has_xidn()) {
    clear_xid_val();
    set_has_xidn();
  }
  xid_val_.xidn_ = value;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 RedoResponse::xidn() const {
  // @@protoc_insertion_point(field_get:OpenLogReplicator.pb.RedoResponse.xidn)
  return _internal_xidn();
}
inline void RedoResponse::set_xidn(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_xidn(value);
  // @@protoc_insertion_point(field_set:OpenLogReplicator.pb.RedoResponse.xidn)
}

// repeated .OpenLogReplicator.pb.Payload payload = 8;
inline int RedoResponse::_internal_payload_size() const {
  return payload_.size();
}
inline int RedoResponse::payload_size() const {
  return _internal_payload_size();
}
inline void RedoResponse::clear_payload() {
  payload_.Clear();
}
inline ::OpenLogReplicator::pb::Payload* RedoResponse::mutable_payload(int index) {
  // @@protoc_insertion_point(field_mutable:OpenLogReplicator.pb.RedoResponse.payload)
  return payload_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::OpenLogReplicator::pb::Payload >*
RedoResponse::mutable_payload() {
  // @@protoc_insertion_point(field_mutable_list:OpenLogReplicator.pb.RedoResponse.payload)
  return &payload_;
}
inline const ::OpenLogReplicator::pb::Payload& RedoResponse::_internal_payload(int index) const {
  return payload_.Get(index);
}
inline const ::OpenLogReplicator::pb::Payload& RedoResponse::payload(int index) const {
  // @@protoc_insertion_point(field_get:OpenLogReplicator.pb.RedoResponse.payload)
  return _internal_payload(index);
}
inline ::OpenLogReplicator::pb::Payload* RedoResponse::_internal_add_payload() {
  return payload_.Add();
}
inline ::OpenLogReplicator::pb::Payload* RedoResponse::add_payload() {
  // @@protoc_insertion_point(field_add:OpenLogReplicator.pb.RedoResponse.payload)
  return _internal_add_payload();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::OpenLogReplicator::pb::Payload >&
RedoResponse::payload() const {
  // @@protoc_insertion_point(field_list:OpenLogReplicator.pb.RedoResponse.payload)
  return payload_;
}

inline bool RedoResponse::has_scn_val() const {
  return scn_val_case() != SCN_VAL_NOT_SET;
}
inline void RedoResponse::clear_has_scn_val() {
  _oneof_case_[0] = SCN_VAL_NOT_SET;
}
inline bool RedoResponse::has_tm_val() const {
  return tm_val_case() != TM_VAL_NOT_SET;
}
inline void RedoResponse::clear_has_tm_val() {
  _oneof_case_[1] = TM_VAL_NOT_SET;
}
inline bool RedoResponse::has_xid_val() const {
  return xid_val_case() != XID_VAL_NOT_SET;
}
inline void RedoResponse::clear_has_xid_val() {
  _oneof_case_[2] = XID_VAL_NOT_SET;
}
inline RedoResponse::ScnValCase RedoResponse::scn_val_case() const {
  return RedoResponse::ScnValCase(_oneof_case_[0]);
}
inline RedoResponse::TmValCase RedoResponse::tm_val_case() const {
  return RedoResponse::TmValCase(_oneof_case_[1]);
}
inline RedoResponse::XidValCase RedoResponse::xid_val_case() const {
  return RedoResponse::XidValCase(_oneof_case_[2]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace pb
}  // namespace OpenLogReplicator

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::OpenLogReplicator::pb::Op> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::OpenLogReplicator::pb::Op>() {
  return ::OpenLogReplicator::pb::Op_descriptor();
}
template <> struct is_proto_enum< ::OpenLogReplicator::pb::ColumnType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::OpenLogReplicator::pb::ColumnType>() {
  return ::OpenLogReplicator::pb::ColumnType_descriptor();
}
template <> struct is_proto_enum< ::OpenLogReplicator::pb::RequestCode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::OpenLogReplicator::pb::RequestCode>() {
  return ::OpenLogReplicator::pb::RequestCode_descriptor();
}
template <> struct is_proto_enum< ::OpenLogReplicator::pb::ResponseCode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::OpenLogReplicator::pb::ResponseCode>() {
  return ::OpenLogReplicator::pb::ResponseCode_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_OraProtoBuf_2eproto
